
import numpy as np
import matplotlib.pyplot as plt
import math
from compressivestrength_and_otherfunctions import get_scaled_corners
from compressivestrength_and_otherfunctions import calculate_centroid_trapezoid
from compressivestrength_and_otherfunctions import calculate_stringer_Ixx_local
from compressivestrength_and_otherfunctions import calculate_Ixx
from bendingdiagrampositiveload import M_pos_load
from Spacing_Functions import rib_places
from Spacing_Functions import spacing_at_position


# Material Properties: Al2024-T81
E = 72.4*10**9            # Young's Modulus [Pa]
nu = 0.33             # Poisson's ratio
sigma_yield = 450e6   # Compressive Yield Strength [Pa]

# Harmonized Wingbox section properties
t_skin = 0.003
rho_Al2024 = 2780
coords_unscaled = [(0.2, -0.02723), (0.7, -0.0066), (0.7, 0.0666), (0.2, 0.08737)] # FB, RB, RT, FT

# Wing Geometry
b = 23.78        # Full Span [m]
half_span = 11.89
c_root = 4.02    # Root chord [m]
c_tip = 1.27     # Tip chord [m]
taper = c_tip / c_root

# Front/Rear Spar locations (fraction of chord)
loc_front = 0.20
loc_rear = 0.70
box_width_frac = loc_rear - loc_front

# Designs WP5 updated

# Normalized Coordinates (Unit Chord c=1)
UNIT_CORNERS = [
    (0.2, -0.02723), (0.7, -0.0066),   
    (0.7, 0.0666),   (0.2, 0.08737)
]

# --- DESIGNS DICTIONARY ---
# scaling_mode = 'full': Scale w_str, t_str, t_skin, t_spar with chord c(y)
# scaling_mode = 'width_only': Scale w_str with c(y), keep t_str, t_skin, t_spar constant
designs = {
    "Design 1": {
        'n_str': 12, 'w_str': 0.015, 't_str': 0.001, 't_skin': 0.0015, 't_spar': 0.0015, 
        'scaling_mode': 'full' 
    },
    "Design 2": {
        'n_str': 6,  'w_str': 0.020, 't_str': 0.002, 't_skin': 0.0015, 't_spar': 0.0015, 
        'scaling_mode': 'full'
    },
    "Design 3": {
        'n_str': 6,  'w_str': 0.015, 't_str': 0.001, 't_skin': 0.0030, 't_spar': 0.0030, 
        'scaling_mode': 'full'
    },
    "Design 4": {
        'n_str': 12, 'w_str': 0.020, 't_str': 0.008, 't_skin': 0.0120, 't_spar': 0.0120, 
        'scaling_mode': 'width_only' # Only width scales, thickness constant
    },
    "Image Design 1": {
        'n_str': 12,
        'w_str': 0.015,     # 15 mm * c(y)
        't_str': 0.004,     # 4 mm (constant)
        't_skin': 0.006,    # 6 mm (constant)
        't_spar': 0.009,    # assume same as skin #changed from 0.006
        'h_max': 0.0820,
        'scaling_mode': 'width_only'
    },

    "Image Design 2": {
        'n_str': 6,
        'w_str': 0.020,     # 20 mm * c(y) 
        't_str': 0.008,     # 8 mm
        't_skin': 0.006,    # 6 mm
        't_spar': 0.006,
        'h_max': 0.0794,
        'scaling_mode': 'width_only'
    },

    "Image Design 3": {
        'n_str': 6,
        'w_str': 0.015,     # 15 mm * c(y)
        't_str': 0.004,     # 4 mm
        't_skin': 0.012,    # 12 mm
        't_spar': 0.012, #kept constant
        'h_max': 0.0807,
        'scaling_mode': 'width_only'
    }
}

# Calculate chord length at spanwise location y
def get_chord(y):
    """Returns chord length at spanwise location y."""
    return c_root * (1 - (1 - taper) * (y / half_span))

# Calculate wingbox dimensions at spanwise location y
def get_box_dims(y):
    """
    Returns wingbox width (b_box) and average height (h_box) at y.
    Based on front/rear spar locations (0.2c and 0.7c).
    """
    c = get_chord(y)
    b_box = c * (0.7 - 0.2) # Box width is 50% of chord [cite: 1759]
    
    # Height approximation (Refine with actual airfoil thickness if available)
    # Using NACA 4412 ~12% thickness as a baseline estimate
    h_box = c * 0.12 * 0.9 
    return b_box, h_box

# Calculate Area Moment of Inertia (Ixx) at location y with actual stringer Area (no longer just point mass).
def calculate_Ixx_str(y, design_params):
    b_box, h_box = get_box_dims(y)
    c = get_chord(y)

    # Design Parameters
    n_str = design_params['n_str']
    t_skin = design_params['t_skin']
    t_spar = design_params['t_spar']
    w_str = design_params['w_str']
    t_str = design_params['t_str']
    h_max= design_params['h_max']
    
    # 1. Stringer Contribution
    # Area of one L-stringer (approximate as two rectangles)
    A_str = (c*w_str * t_str) + ((c*w_str - t_str) * t_str)
    y_centroid=((t_str/2)*c*w_str*t_str+((c*w_str - t_str) *t_str)*(c*w_str - t_str)/2)/A_str
    x_centroid=y_centroid
    I_strcrosssection=c*w_str*t_str*y_centroid**2+t_str*c*w_str**3*(1/12)+c*w_str*t_str*(c*w_str-y_centroid)**2

    # y_max location
    y_max=h_max*c
    
    return I_strcrosssection, A_str, y_max

def sigma_crit(y, n, inital_spacing):
    L= spacing_at_position(inital_spacing, half_span, n, y)
    I, A, y_max = calculate_Ixx_str(y, designs["Image Design 3"])
    sigma_crit = math.pi**2*E*I/((L)**2*A)
    return sigma_crit

def sigma_distribution(y):
    Ixx = calculate_Ixx(y, designs["Image Design 3"])
    I, A, y_max = calculate_Ixx_str(y, designs["Image Design 3"])
    Mx = M_pos_load(y)

    sigma_comp = abs(Mx*y_max/Ixx)
    return sigma_comp



number_of_ribs=12
initial_spacing1=1.3
position=0
positions=[]
critical_stresses=[]
stresses=[]
margins_of_error=[]
i=0
while position <=half_span:
    stresscr=sigma_crit(position, number_of_ribs, initial_spacing1)
    stress =sigma_distribution(position)
    margin_of_error=stresscr/stress
    positions.append(position)
    critical_stresses.append(stresscr)
    stresses.append(stress)
    margins_of_error.append(margin_of_error)
    position = position + 0.01

rib_positions, rib_spacings = rib_places(initial_spacing1, half_span, number_of_ribs)

print(rib_positions, rib_spacings)
#max actually means min
max_mos_per_bay = []
bay_centers = []

for i in range(len(rib_positions) - 1):
    y_start = rib_positions[i]
    y_end = rib_positions[i + 1]

    # indices of points inside this rib bay
    indices_in_bay = [
        k for k, y in enumerate(positions)
        if y_start <= y < y_end
    ]

    if indices_in_bay:
        mos_values = [margins_of_error[k] for k in indices_in_bay]
        max_mos = min(mos_values)

        max_mos_per_bay.append(max_mos)
        bay_centers.append(0.5 * (y_start + y_end))





#plt.figure(figsize=(10,6))              # nice large figure
#plt.plot(positions, stresses, label="Stress distribution")
#plt.plot(positions, critical_stresses, label="Critical stress", linestyle="--")

#plt.xlabel("Position along span [m]")
#plt.ylabel("Stress [Pa]")
#plt.title("Stress vs. Position")
#plt.grid(True)
#plt.legend()

#plt.show()

#plt.figure(figsize=(10,6))              # nice large figure
#plt.plot(positions, margins_of_error, label="Margin of Safety Column Buckling")

#plt.xlabel("Position along span [m]")
#plt.ylabel("Margin of Safety [-]")
#plt.title("Margin of Safety vs. Position")
#plt.ylim(0, 5)  
#plt.grid(True)
#plt.legend()

#plt.show()

plt.figure(figsize=(10,6))
plt.step(
    rib_positions[:-1],
    max_mos_per_bay,
    where="post",
    label="Max MoS per rib bay"
)

plt.xlabel("Spanwise position [m]")
plt.ylabel("Margin of Safety [-]")
plt.title("Maximum Margin of Safety per Rib Bay")
plt.ylim(0, 5) 
plt.grid(True)
plt.legend()
plt.show()

#Optimal design results for just column buckling:
#design 1: 1.35, 11
#design 2: 1.75, 8
#design 3: 1.6, 9

#after redesign

#design 1: 1.05, 12
#design 3: 1.31, 