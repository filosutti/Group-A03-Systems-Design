import numpy as np
from scipy.integrate import quad
import matplotlib.pyplot as plt

# -----------------------------
# Load inputs
# -----------------------------
from TL import LperSpan0, MperSpan0
from alban_code_3 import calculate_wingbox_centroid

L = 11.89   # Half-span of the wing

# -----------------------------
# Aerodynamic moment arm: Distance between flexural axis and aerodynamic center
# CCW = +
# -----------------------------
def d(x):
    c_r = 4.02
    span = 11.89
    taper = 0.316
    c_t = c_r * taper
    chord = c_r - (c_r - c_t) * (x / span)
    return 0.20 * chord

# -----------------------------
# Interpolated aerodynamic loads from XFLR5 data
# -----------------------------
Lift   = LperSpan0
Moment = MperSpan0

# -----------------------------
# Distributed torque densities
# -----------------------------
def tau_l(x):
    return abs(Lift(x) * d(x))

def tau_m(x):
    return abs(Moment(x))

# -----------------------------
# Engine point torque
# -----------------------------
w_engine    = 4800 * 0.45359237 * 9.81   # N  
thrust_arm  = 2.32 + 0.3
engine_arm  = 2.495
x_engine    = 3.75
T_thrust    = 83.1e3

MomentPoint = abs((w_engine * engine_arm) - (T_thrust * thrust_arm))

# -----------------------------
# Root torque T0 – ensures T(L)=0
# -----------------------------
def T0_calc():
    tl, _ = quad(tau_l, 0, L)
    tm, _ = quad(tau_m, 0, L)
    return tl + MomentPoint - tm

T0 = T0_calc()

# -----------------------------
# Internal torque distribution
# -----------------------------
def torque_pos_loadfactor(x):
    tl, _ = quad(tau_l, 0, x)
    tm, _ = quad(tau_m, 0, x)
    tpoint = MomentPoint if x >= x_engine else 0.0
    return -T0 + tl - tm + tpoint

# -----------------------------
# Plot internal torque diagram
# -----------------------------
x_vals = np.linspace(0, L, 400)
T_vals = np.array([torque_pos_loadfactor(xi) for xi in x_vals])

T_before = torque_pos_loadfactor(x_engine - 1e-6)
T_after  = torque_pos_loadfactor(x_engine + 1e-6)

plt.figure(figsize=(10, 6))
plt.plot(x_vals, T_vals / 1e3, label='Internal Torque T(x)', color='blue')
plt.plot([x_engine, x_engine], [T_before / 1e3, T_after / 1e3],
         color='red', linestyle='--', label='Engine Point Torque')
plt.scatter([x_engine], [T_after / 1e3], color='red')
plt.title('Internal Torque Distribution Along Wing Span')
plt.xlabel('Spanwise Location x (m)')
plt.ylabel('Internal Torque T(x) (kN·m)')
plt.axhline(0, color='black', linewidth=0.8, linestyle='--')
plt.legend()
plt.grid()
plt.show()

# -----------------------------
# Inertia Calculation
# -----------------------------
def inertia_calculation(z):
    ns = 1
    As = 0.0025

    coords = [
        (0.2, -0.02723),  
        (0.7, -0.0066),   
        (0.7, 0.0666),    
        (0.2, 0.08737)    
    ]
    t_skin = 0.001
    rho_Al2024 = 2780

    stringers_data = [
        (0.45, 0.07, 0.0005, rho_Al2024),
        (0.45, -0.015, 0.0005, rho_Al2024)
    ]

    # Wingbox centroid
    cx, cy = calculate_wingbox_centroid(coords, t_skin, rho_Al2024, stringers_data)
    c = -0.2313*z + 4.02
    ce = (c * cx, c * cy)

    x = [0.2*c, 0.7*c, 0.7*c, 0.2*c]
    y = [-0.02723*c, -0.0066*c, 0.0666*c, 0.08737*c]
    x.append(x[0])
    y.append(y[0])

    Ixxtot = Iyytot = Ixytot = 0
    t = t_skin

    for i in range(len(x)-1):
        dx = x[i+1]-x[i]
        dy = y[i+1]-y[i]
        l = np.sqrt(dx**2 + dy**2)
        A = l*t

        d_y = x[i] + dx/2 - ce[0]
        d_x = y[i] + dy/2 - ce[1]

        if i == 1 or i == 3:
            x2, y2 = x[i], y[i]
            for k in range(ns):
                d_y2 = x2 - ce[0]
                d_x2 = y2 - ce[1]
                Ixxtot += As*d_x2**2
                Iyytot += As*d_y2**2
                Ixytot += As*d_x2*d_y2
                x2 += dx/ns
                y2 += dy/ns

        Ixx = (t*(l**3)*(dy/l)**2)/12 + A*(d_x**2)
        Iyy = (t*(l**3)*(dx/l)**2)/12 + A*(d_y**2)
        Ixy = (t*(l**3)*(dx*dy)/(l**2))/12 + A*(d_x*d_y)

        Ixxtot += Ixx
        Iyytot += Iyy
        Ixytot += Ixy

    J = Ixxtot + Iyytot
    return Ixxtot, Iyytot, Ixytot, J

# -----------------------------
# Compute v(z)
# -----------------------------
G = 28e9  # Pa

def integrand(z_val):
    return torque_pos_loadfactor(z_val) / inertia_calculation(z_val)[3] / G

def firstint(z_val):
    return quad(lambda s: integrand(s), 0, z_val)[0]

z_vals = np.linspace(0, L, 100)
v_values = np.array([firstint(z_val) for z_val in z_vals])

# -----------------------------
# Plot v(z)
# -----------------------------
plt.figure(figsize=(8,5))
plt.plot(z_vals, v_values)
plt.xlabel('z (m)')
plt.ylabel('v(z)')
plt.title('Wing Twist / Deflection Function')
plt.grid(True)
plt.show()
